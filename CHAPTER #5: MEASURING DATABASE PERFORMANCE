Oracle 19c PERFORMANCE MANAGEMENT AND TUNING:
============================================

CHAPTER #5: MEASURING DATABASE PERFORMANCE
--------------------------------------------------
==========================
About Database Statistics:
==========================

Time Model Statistics:
----------------------
This statistic represents the total time spent in database calls for foreground sessions and is an indicator of the total instance workload. 
DB time = time of instance startup + CPU and wait times of all foreground non-idle sessions.
Note: It is possible that the DB time can exceed the actual time elapsed after the instance started.
Ultimately, the objective in tuning an Oracle database is to reduce the time that users spend in performing an action on the database, or to simply reduce DB time.
Time model statisticcan viewed by V$SESS_TIME_MODEL and V$SYS_TIME_MODEL.

col sid format 999999
col dbtime format 9999999999999
col waittime format 9999999999999
col waitpct format 99999.99
col oncpupct format 99999.99
select sid
           ,value dbtime
           ,waittime waittime
           ,round((waittime/value)*100,2) waitpct
           ,round(((value-waittime)/value)*100,2) oncpupct
      from(
          select sid
                ,stat_id
                ,stat_name
                ,value
                ,value - (lead(value,1) over(partition by sid order by 
                               sid,stat_name desc)) waittime
              from v$sess_time_model
              where stat_name in ('DB time','DB CPU')
          )
      where stat_name='DB time'
          and waittime>0
      order by waitpct desc
  ;

Active Session History Statistics:
----------------------------------

Active session = session connected to the database and waiting for an event that does not belong to wait class.
Active Session History (ASH) enables you to examine and perform detailed analysis on both current data in the V$ACTIVE_SESSION_HISTORY view and historical data in the DBA_HIST_ACTIVE_SESS_HISTORY view.

Wait Events Statistics:
-----------------------
Wait event data reveals various symptoms of problems that might be impacting performance, such as latch contention, buffer contention, and I/O contention.

Administrative: Waits resulting from DBA commands that cause users to wait (for example, an index rebuild)

Application:Waits resulting from user application code (for example, lock waits caused by row level locking or explicit lock commands)

Cluster:Waits related to Oracle Real Application Clusters resources (for example, global cache resources such as 'gc cr block busy')

Commit:This wait class only comprises one wait event - wait for redo log write confirmation after a commit (that is, 'log file sync')

Concurrency:Waits for internal database resources (for example, latches)

Configuration:Waits caused by inadequate configuration of database or instance resources (for example, undersized log file sizes, shared pool size)

Idle:Waits that signify the session is inactive, waiting for work (for example, 'SQL*Net message from client')

Network:Waits related to network messaging (for example, 'SQL*Net more data to dblink')

Other:Waits which should not typically occur on a system (for example, 'wait for EMON to spawn')

Queueing:Contains events that signify delays in obtaining additional data in a pipelined environment. The time spent on these wait events indicates inefficiency or other problems in the pipeline. It affects features such as parallel queries or DBMS_PIPE PL/SQL packages.

Scheduler:Resource Manager related waits (for example, 'resmgr: become active')

System I/O:Waits for background process I/O (for example, DBWR wait for 'db file parallel write')

User I/O:Waits for user I/O (for example 'db file sequential read')

The V$SYSTEM_EVENT view shows wait event statistics for the foreground activities of a database instance and the wait event statistics for the database instance. The V$SYSTEM_WAIT_CLASS view shows these foreground and wait event statistics at the instance level after aggregating to wait classes. V$SESSION_EVENT and V$SESSION_WAIT_CLASS show wait event and wait class statistics at the session level.

set pages 50000 lines 32767
col event format a60

select event, total_waits, time_waited
from v$system_event e, v$event_name n
where n.event_id = e.event_id
and n.wait_class !=’Idle’
and n.wait_class = (select wait_class from v$session_wait_class
where wait_class !=’Idle’
group by wait_class having
sum(time_waited) = (select max(sum(time_waited)) from v$session_wait_class
where wait_class !=’Idle’
group by (wait_class)))
order by 3
/

Session and System Statistics:
------------------------------
A large number of cumulative database statistics on a system and session level are accessible using the V$SYSSTAT and V$SESSTAT views.


=================================
Interpreting Database Statistics:
=================================

Using Hit Ratios:
-----------------
Ratios may include the buffer cache hit ratio, the soft-parse ratio, and the latch hit ratio. Do not use these ratios as definitive identifiers of whether a performance bottleneck exists. Instead, use them as indicators.

Using Wait Events with Timed Statistics:
----------------------------------------
Setting TIMED_STATISTICS to TRUE at the instance level directs the database to gather wait time for events, in addition to available wait counts. If it is the highest ranked wait event when ordered by time waited. However, if the event accounts for 30 minutes of a 45-minute period, then the event is worth investigating.

Using Wait Events without Timed Statistics:
-------------------------------------------
Although the events with the largest number of waits might indicate a potential bottleneck, they might not be the main bottleneck. This situation can happen when an event is waited for a large number of times, but the total time waited for that event is small or vice versa.

Comparing Database Statistics with Other Factors:
-------------------------------------------------
Even an event that had a wait of 30 minutes in a 45-minute period might not be indicative of a performance problem if you discover that there were 2000 users on the system, and the host hardware was a 64-node computer.
